using Plots: make_fillrange_from_ribbon
# Coronavirus Analysis
Working directory must be Cov2_Analysis directory

## Mean and Standard Deviation
Finding mean sequence length, standard devation for length, mean gc content and standard deviation for gc content for CoV sequences.

```julia 
using BISC195Bioinformatics

return mean_and_std_fasta("data/CoV_sequences.fasta")
```

## Minimum and Maximum

Finding length of smallest and largest sequence for CoV sequences. 

```julia
seq_lengths = sequence_lengths("data/CoV_sequences.fasta")

min_length = minimum(seq_lengths)
max_length = maximum(seq_lengths)

return min_length, max_length
```

## Identifying Outliers

Using histogram to spot sequence length outliers in CoV sequences. Added more descriptive axis labels and removed legend.

```julia
using Plots

histogram(seq_lengths, 
xlabel = "Sequence Length",
ylabel = "Frequency",
legend = false)
```
## Filtering sequences with more than 25k bases

Modifying sequence_length function from BISC195 Bioinformatics package to output new vectors only containing sequences with >25k bases.
(Also creates new vector with adjoining headers).

I modified the sequence_length function instead of just calling it because sequence_length already pulls the header and sequence arrays from parse_fasta. 
This way I don't have to call parse_fasta a second time to get the original vectors for a slice. 
Included sequence lengths in tuple output for use in next step.

```julia
"""
    morethan25k(path)

Given a path to a fasta file, outputs tuple containing only sequences, headers, and sequence lengths for sequences with more than 25k bases.
"""
function morethan25k(path)
    seq_lengths = []
    headers = parse_fasta(path)[1]
    sequences = parse_fasta(path)[2]

    for sequence in sequences 
        push!(seq_lengths, length(sequence))
    end
    
    keep = findall(x -> x > 25000, seq_lengths)
    
    headers_25k = headers[keep]
    sequences_25k = sequences[keep]

    return tuple(headers_25k, sequences_25k, seq_lengths)
end
```
Making a new histogram using filtered fasta file. 

```julia
seq_lengths = morethan25k("data/CoV_sequences.fasta")[3]

histogram(seq_lengths, 
xlabel = "Sequence Length",
ylabel = "Frequency",
legend = false)
```
## Unique Kmers

Modifying question 4 from assignment 04 to create function that takes two arguments (sequence, k) and returns all of the unique kmers of length k. 
Set has built-in function of avoiding repeat entries, so no need to check if kmer is in kmers.

Added loop to stop evaluating kmer if invalid base is encountered. 

```julia 
"""
    uniquekmers(sequence, k)

Given a sequence and an integer k, returns all unique sequences of length k. 
Does not recognize kmers containing invalid bases. 

Example: 
julia> seq = "ATGCGATVGTAC";

julia> uniquekmers(seq, 4)
Set{Any} with 5 elements:
  "GTAC"
  "TGCG"
  "ATGC"
  "CGAT"
  "GCGA"
"""
function  uniquekmers(sequence, k)
    1 <= k <= length(sequence) || error("k must be a positive integer less than the length of the sequence") ##Throws error if k is larger than sequence length

    kmers = Set() ## initialize set
     
    stopindex = length(sequence) - k + 1

    for i in 1:stopindex
        kmer = sequence[i:(i+k-1)]
        kmer = uppercase(kmer) 
        
        keep = true 

        for base in kmer       ## Changes flag to false if invalid base encountered
            if !occursin(base, "AGCT") 
                keep = false
                break          ## Stop evalulating kmer once the first invalid base is encountered
            end
        end

        if keep                 ## If flag is still true
            push!(kmers, kmer)  ## Push kmer to set
        end
    end
    return kmers
end
```
## Comparing Unique kmers

Calculating distance metric between two sets of kmers. Identical sets return value of 0, sets with no overlap whatsoever return 1. 

Distance metric defined as:
1 - (length of intersection / length of union)
OR 
((length of set1 - set2) + (length of set2 - set1)) / length of union

```julia
intersect_length = length(intersect(set1, set2))
union_length = length(union(set1, set2))

distancemetric = 1 - (intersect_length / union_length)
```
